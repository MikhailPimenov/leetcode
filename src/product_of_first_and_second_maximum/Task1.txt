Этот алгоритм спрашивают на стартовые позиции разработчика (не на стажёра).

Глобально:
Написать функцию, которая возвращает произведение первого максимума на второй максимум.
Функция должна принимать массив, то есть указатель на нулевой элемент массива и количество элементов.
[1, 2, 3, 4]          	-> 12 (3*4)
[4, 0, -1, 5] 			-> 20 (4*5)
[5, 5, 5, 0] 			-> 25 (5*5)
[1, 4, -6, -3, 8, 9] 	-> 72 (8*9)



По шагам. Сделать нужно каждый шаг.
После каждого шага нужно запускать программу.

Всё компилировать/компоновать нужно со всеми флагами. Так как файл один, то и компиляция, и компоновка будут одной командой:
gcc -Wall -Werror -Wextra -std=c11 -pedantic product_of_first_and_second_maximum.c -o product_of_first_and_second_maximum.out
Запуск ./product_of_first_and_second_maximum.out

После каждого пункта должен быть выполнен коммит. Коммиты можно делать чаще, но не реже каждого успешного пункта.

1. Создай пустой файл product_of_first_and_second_maximum.c



2. Создай в нём пустую функцию мейн, которая ничего не делает и возвращает 0.



3. Создать пустую функцию get_product(....), которая будет
принимать массив и возвращать целое число. Это заготовка функции, она на данном этапе
ничего не делает. 

Чтобы не было ошибок о неиспользуемых переменных, пусть она должна вернуть 
нулевой элемент массива, умноженный на длину. return array[0] * length; или return array[0 * length]; 
главное, чтобы и array, и length были задействованы. 

Функция не должна изменять массив. Компилятор должен 
за этим следить, это одно слово добавить в одном месте.



4. Напиши функцию print_array(....), которая ничего не возвращает, принимает массив и печатает его на одной строчке.
А после массива переводит на следующую строку. 

Функция не должна изменять массив. Компилятор должен  за этим следить.

Чтобы работала печать, нужно подключить <stdio.h>.

Создай в мейне массив, сразу присвоив в него значения через = {1, 2, 1, 6, 5}; 
Массив не будет меняться, пусть компилятор следит за этим.
Создай в мейне длину этого массива, используя оператор sizeof. sizeof всего массива / sizeof нулевого элемента.
Длина не будет меняться, пусть компилятор следит за этим.
Напечатай этот массив, используя print_array(....). 


4.1 Массив и вызов print_array(....) из мейна можно удалить



5.1 Напиши функцию тестирования get_product_test(....). Она ничего не возращает и ничего не принимает.
В этом пункте в этой функции будет один случай тестирования. В следующих уже будет несколько.
В этой функции:
	а) определяется массив и его длина (так же через sizeof) 
	б) определяется переменная expected, в которой должен быть записан ожидаемый 
результат от функции (то есть если массив 1,4,7,0 , то expected = 28) 
	в) определяется переменная actual, в которой должен быть результат вызова функции get_product(....), которой
в качестве параметров были переданы массив и его длина
	г) далее если actual и expected совпадают, вывести "test: ok", если не совпадают, вывести "test: FAILED"
	д) вызови функцию


5.2 Если expected и actual НЕ совпали, нужно вывести помимо FAILED на следующих строках
"input: " и далее массив, который был скормлен функции get_product(....), чтобы получить actual
"expected: " и ожидаемый результат (в переменной expected)
"actual: " и реальный результат (в переменной actual)


5.3 Нужно сравнение и вывод результата одного случая тестирования занести в отельную функцию test_case(....)
Функция не будет ничего возвращать, но принимать будет всё то, что нужно для ей для функционирования.

	а) заведи функцию test_case(....), ничего не возвращает. И пока ничего не принимает. И пустое тело у неё должно быть
	б) перемести пункт г) из задания 5.1 в тело этой пока пустой функции test_case(....), но так, 
чтобы между "test" и ": ok" или ": FAILED" был номер теста, то есть чтобы было "test #3: FAILED" или "test #5: ok". 
Номер теста будет передаваться в качестве параметра в функцию 
	в) перемести сравнение и вывод результатов теста из 5.2 из функции get_product_test(....) в тело функции test_case(....) 
после "test #..."
	г) внутри тела функции test_case(....) в случае совпадения actual и expected нужно увеличить счётчик успешных тестов на единицу.
Этот счётчик будет модифицироваться внутри этой функции и его результат должен будет взят снаружи этой функции, то есть функция
test_case(....) будет модифицировать внешнюю переменную.
	д) сделать так, чтобы test_case(....) принимала все нужные параметры, то есть чтобы внутри функции test_case(....)
не было никаких переменных, про которые компилятор не знает. Счётчик успешных тестов передаётся по-особому, потому что
функция test_case(....) должна модифицировать внешнюю переменную.
	г) в функции get_product_test(....) в начале завести переменную test_number и number_of_tests_passed
	е) заменить 5.2 в функции get_product_test(....) на вызов функции test_case(....), передавая все нужные test_case(....) 
параметры. После вызова test_case(....) увеличить на 1 test_number

В функции get_product_test(....) сейчас определяется в начале переменная для номера теста, переменная для количества успешных тестов,
массив и его длина, expected и actual (через вызов get_product(....), которой передаётся массив и его длина)


5.4 а) поместить определение массива, его длины, expected и actual, вызов test_case(....) и увеличение счётчика тестов
в ещё одни фигурные скобки. То есть внутри тела функции get_product_test переменная для номера теста, 
переменная для количества успешных тестов, а затем уже в ещё одних фигурных скобках определяется массив, его длина,
expected, actual, вызов test_case(....), инкремент номера теста
    б) скопировать всё, что внутри фигурных скобок вместе с фигурными скобками и вставить сюда же в функцию get_product_test(....)
пять раз. При этом нужно менять определение массива и expected. То есть если было при определении массива = {1, 2, 3};  expected 6, 
то будет, например, = {1, 0, 9, 0, 4, 7}; и expected 63, и так пять раз разные массивы должны быть. Длины массивов менять вручную не надо,
они сами определяются из sizeof(....) / sizeof(....)
    в) после 5 случаев вывести 
"SUMMARY: 
passed 1/5
percentage 0.2"
то есть сколько прошло тестов и сколько было всего и нецелым числом.
При делении целого на целое нужно привести их сначала к типу с плавающей точкой, иначе целочисленное деление будет и всегда будет ноль.
На данном этапе функция get_product(....) ещё не реализована, поэтому все тесты будут FAILED, если где-то случайно не совпадёт.


5.5 a) заменить вызов get_product(....) внутри на get_product_test(....) на вызов algorithm(....). algorithm - указатель на функцию,
возвращающую целое число и принимающую массив. Этот указатель должен быть передан в функцию get_product_test(....) в качестве параметра
(синтаксис указателя на функцию самый сложный в языке С/С++)
    б) вызвать функцию get_product_test(....) в мейне, передав ей в качестве параметра функцию get_product


5.6 Сделай так, чтобы перед тестами была информация о том, что тестируем.
Для этого передай переменную-строку greetings в get_product_test(....) и напечатай её в начале функции get_product_test(....) и переведи на следующую строку,
то есть теперь get_product_test(....) принимает два параметра.
То есть будет не 
"test #1: ok"
"test #2: ok"
....
а 
"Testing get_product"
"test #1: ok"
"test #2: ok"




5.7 Добавь возможность не печатать input, expected, actual, если тест провалился. Для этого 
	а) передай в функцию get_product_test(....) целочисленную переменную is_verbose, которая принимает значение 0 или 1, то есть
get_product_test(....) принимает уже три переменной
	б) в функции get_product_test(....) is_verbose передаётся в функцию test_case(....), 
то есть test_case(....) принимает на одну переменную теперь больше.
	в) в test_case(....) в случае провала теста печатать input, expected, actual только если is_verbose равен 1.


5.8 Добавь enum Boolean, у которого внутри будет две именные константы, True = 1 и False = 0.
Это нужно для того, чтобы is_verbose назначался не 0 или 1, а False или True. Это улучшит читаемость кода.


5.9 Чтобы не передавать много параметров в test_case(....), объедини их в структуру. 
	a) в структуре TestCase будет expected, actual, input, input_length
	б) передавай эту структуру по адресу, чтобы не было лишнего копирования
	в) эта структура внутри test_case(....) меняться не должна. Компилятор должен за этим следить



6. Напиши функцию get_product(....), которая принимает массив, а возвращает произведение первого максимума на второй. В идеале 
функция должна проходить по массиву только один раз. Такое решение будет оптимальным по времени. Функция не должна использовать 
дополнительную память, то есть где-то запоминать массив 


